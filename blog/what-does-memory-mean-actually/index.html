<!DOCTYPE html><html lang="en" data-astro-cid-ouamjn2i> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="A terminal-styled developer blog"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><title>What does memory mean actually?</title><link rel="stylesheet" href="/_astro/_slug_.GJexHCZG.css">
<link rel="stylesheet" href="/_astro/_slug_.TTX37v3e.css"><script type="module">const c=document.getElementById("search-button");c?.addEventListener("click",()=>{document.dispatchEvent(new CustomEvent("toggle-search"))});const n=document.getElementById("theme-toggle"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");(e==="dark"||!e&&o)&&document.documentElement.classList.add("dark-theme");n?.addEventListener("click",()=>{const t=document.documentElement.classList.toggle("dark-theme");localStorage.setItem("theme",t?"dark":"light")});
</script>
<script type="module" src="/_astro/page.DZtx3eTe.js"></script></head> <body data-astro-cid-ouamjn2i> <header class="header" data-astro-cid-3ef6ksr2> <div class="terminal-header" data-astro-cid-3ef6ksr2> <div class="terminal-dots" data-astro-cid-3ef6ksr2> <div class="dot red" data-astro-cid-3ef6ksr2></div> <div class="dot yellow" data-astro-cid-3ef6ksr2></div> <div class="dot green" data-astro-cid-3ef6ksr2></div> </div> <nav class="terminal-nav" data-astro-cid-3ef6ksr2> <a href="/" class="command " data-astro-cid-3ef6ksr2>cd ~</a> <a href="/blog" class="command active" data-astro-cid-3ef6ksr2>cd ~/blog</a> <a href="/random" class="command " data-astro-cid-3ef6ksr2>rand</a> <a href="/whoami" class="command " data-astro-cid-3ef6ksr2>whoami</a> <a href="/ping" class="command " data-astro-cid-3ef6ksr2>ping</a> <a href="/assets/resume/PrabhavDogra.pdf" target="_blank" rel="noopener noreferrer" class="command" data-astro-cid-3ef6ksr2>cd ~/resume</a> </nav> <span class="prompt" data-astro-cid-3ef6ksr2>$</span> <button id="search-button" class="search-button" data-astro-cid-3ef6ksr2>
search <span class="search-term" data-astro-cid-3ef6ksr2>--query='search term'</span> </button> </div> </header>   <main class="container" data-astro-cid-ouamjn2i> <div class="content" data-astro-cid-ouamjn2i> <div class="blog-title" data-astro-cid-ouamjn2i>~/blog</div>   <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <div class="blog-path" data-astro-cid-4dqtj3le>~/blog/what-does-memory-mean-actually?</div> <article class="blog-post" data-astro-cid-4dqtj3le> <h1 class="blog-post-title" data-astro-cid-4dqtj3le>What does memory mean actually?</h1> <div class="blog-post-date" data-astro-cid-4dqtj3le>📅 April 4, 2025</div> <div class="blog-post-content markdown-content" data-astro-cid-4dqtj3le>  <p>While exploring how Go manages memory, I stumbled upon an intricate hierarchy that determines how fast data moves between the CPU and RAM. Go’s runtime optimizations, like garbage collection and stack allocation, made me curious about what happens under the hood. This led me to registers, caches (L1, L2, L3), and RAM—each playing a crucial role in balancing speed and storage.</p>
<h2 id="prerequisites-whats-a-cpu-cycle">Prerequisites: What’s a CPU Cycle?</h2>
<p><strong>CPU Cycle:</strong>
- It’s the smallest unit of processing that a CPU can do.
- Each cycle allows the CPU to execute instructions like fetching data, performing arithmetic, or storing results.
- For example: the method <code>atomic.CompareAndSwap</code> in go is executed as follows:
- It reads a value from memory.
- It compares it with an expected value.
- If they match, it writes a new value.
- This requires at least three steps (read, compare, write), which take multiple cycles.
- A single 1GHz CPU can complete one CPU cycle in 1 nanosecond.
- Similarly, a 3GHz CPU can complete one CPU cycle in 0.33 nanoseconds.
- Not every operation takes 1 cycle
- Simple instructions like integer addition (a + b) may take 1 cycle.
- More complex operations (e.g., division, memory access) can take multiple cycles.</p>
<p><img  src="/_astro/what-does-memory-mean-actually-1.C1nl7FVO_Z28rqlh.webp" alt="Clock edge" width="616" height="202" loading="lazy" decoding="async"></p>
<p><strong>NOTE:</strong> Here <strong>Period = Clock Cycle</strong></p>
<p><strong>Clock edge</strong>
A clock edge refers to the transition point of a clock signal where changes in a digital circuit occur. The clock signal is a periodic waveform (square wave), and it has two main edges:</p>
<ul>
<li><strong>Rising Edge (Positive Edge)</strong>
<ul>
<li>The transition from low (0) to high (1).</li>
<li>Many digital circuits, including registers and flip-flops, are designed to capture input and update their state on this edge.</li>
</ul>
</li>
<li><strong>Falling Edge (Negative Edge)</strong>
<ul>
<li>The transition from high (1) to low (0).</li>
<li>Some circuits use this edge for synchronization, though it is less common than the rising edge.</li>
</ul>
</li>
</ul>
<p><strong>Why is the Clock Edge Important?</strong></p>
<ul>
<li>It synchronizes operations in digital circuits.</li>
<li>Registers and flip-flops capture and store data only on a specific edge, ensuring controlled data flow.</li>
<li>In CPU pipelines, clock edges trigger different stages like instruction fetch, decode, execute, etc.</li>
</ul>
<h2 id="understanding-computer-memory-hierarchy">Understanding Computer Memory Hierarchy</h2>
<ol>
<li><strong>Registers (Fastest, Smallest)</strong>
<ul>
<li>Located inside the CPU, closest to the execution units.</li>
<li>Stores data for immediate operations (e.g., arithmetic calculations).</li>
<li>Extremely small (few bytes) but operates at CPU clock speed.</li>
<li><strong>Access time:</strong> 1 CPU cycle (fastest).</li>
</ul>
</li>
<li><strong>L1 Cache (Level 1)</strong>
<ul>
<li>Smallest and fastest cache (typically 32KB to 128KB per core).</li>
<li>Directly integrated into the CPU core.</li>
<li>Stores frequently used instructions (will discuss this later) and data for ultrafast access.</li>
<li><strong>Access time:</strong> 2-4 CPU cycles.</li>
</ul>
</li>
<li><strong>L2 Cache (Level 2)</strong>
<ul>
<li>Larger than L1 (256KB to a few MB per core).</li>
<li>Slightly slower than L1 but still much faster than RAM.</li>
<li>Used to store recently accessed data that might be needed again soon.</li>
<li><strong>Access time:</strong> 10-20 CPU cycles.</li>
</ul>
</li>
<li><strong>L3 Cache (Level 3)</strong>
<ul>
<li>Shared among multiple CPU cores, ranging from a few MB to tens of MB.</li>
<li>Acts as a buffer between L2 and RAM, reducing latency for core-to-core communication.</li>
<li><strong>Access time:</strong> 30-60 CPU cycles.</li>
</ul>
</li>
<li><strong>RAM (Random Access Memory)</strong>
<ul>
<li>Main working memory for the system (GBs in size).</li>
<li>Much slower than CPU caches but holds more data.</li>
<li>Stores active processes and data that aren’t frequently used by the CPU.</li>
<li><strong>Access time:</strong> 100+ CPU cycles.</li>
</ul>
</li>
</ol>
<h2 id="registers-the-fastest-storage">Registers: The Fastest Storage</h2>
<h3 id="what-are-registers">What Are Registers?</h3>
<p>Registers are ultra-fast, small storage units embedded directly inside a computer’s CPU (Central Processing Unit). They are temporary holding areas for data, instructions, or memory addresses that the CPU needs to access immediately during computations. Registers are the fastest type of memory in a computer, designed to minimize delays in processing.</p>
<h3 id="how-registers-work">How Registers Work?</h3>
<ul>
<li><strong>Fetching Data:</strong> When the CPU needs to perform an operation (e.g., 5 + 3), it first copies the values 5 and 3 from RAM into two registers.</li>
<li><strong>Processing:</strong> The CPU’s arithmetic logic unit (ALU) performs the addition directly using the values stored in the registers.</li>
<li><strong>Storing Results:</strong> The result (8) is placed into another register, which can either be used for further operations or written back to RAM.</li>
</ul>
<ol>
<li>
<p><strong>Basic Structure: Flip-Flops</strong></p>
<ul>
<li><strong>Core Component:</strong> Registers are built using D-type flip-flops, each flip-flop just stores one bit. A 32-bit register, for example, contains 32 flip-flops.</li>
<li><strong>Function:</strong> Each flip-flop has:
<ul>
<li><strong>Data Input (D):</strong> Receives the bit to store.</li>
<li><strong>Write Enable (WE):</strong> Controls whether the flip-flop should capture and store the input value on the next active clock edge.</li>
<li><strong>Clock Input (CLK):</strong> Provides the timing signal that synchronizes when data is captured by the flip-flop. The flip-flop updates its value on the rising edge of the clock.</li>
<li><strong>Output (Q):</strong> Provides the stored bit.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Data Storage and Clock Synchronization</strong></p>
<p><strong>Writing Data:</strong></p>
<ul>
<li>When the CPU writes to a register:
<ul>
<li>The write enable signal for the register is activated.</li>
<li>Data is placed on the <strong>input bus</strong>.  The input bus is a set of electrical connections that carry data to the register.</li>
<li>In the <strong>next rising edge of the clock</strong>, the flip-flops capture the input values.</li>
</ul>
</li>
</ul>
<p><strong>Reading Data:</strong></p>
<ol>
<li><strong>Stored Data in Flip-Flops</strong>
<ul>
<li>A register consists of multiple flip-flops, each storing a single bit. Once a value is stored in a flip-flop, it remains available at its output until changed by a new write operation. However, this stored value is not automatically placed on the CPU’s internal bus—something must send the data when the data is read.</li>
<li>Each flip-flop’s output is connected to a tri-state buffer, which controls whether the stored bit is driven onto the bus connecting CPU and register (for reading the bit).</li>
</ul>
</li>
<li><strong>Role of the Tri-State Buffer</strong>
<ul>
<li>Tri-State Buffer ensures conflict-free (kindof like mutex) data access, enabling the CPU to perform billions of operations per second reliably.</li>
<li>A tri-state buffer is a special circuit that can either:
<ul>
<li><strong>Tri-State Buffer Enabled:</strong> Passes the stored data from the register to the bus connecting CPU and register.</li>
<li><strong>Tri-State Buffer Disabled:</strong> Disconnects the register from bus connecting CPU and register.</li>
</ul>
</li>
<li>This is necessary because multiple registers share the same internal bus, and only one should be active at a time to avoid conflicting reads and writes (more of a hardware constraint).</li>
<li>The enable signal is synchronized with the CPU clock to ensure stable data transfer.</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="types-of-registers-a-little-extra-context">Types of Registers (A little extra context)</h3>
<ul>
<li><strong>General-Purpose Registers:</strong>
<ul>
<li>Used for temporary data storage and most calculations.</li>
</ul>
</li>
<li><strong>Special-Purpose Registers:</strong>
<ul>
<li><strong>Program Counter (PC):</strong> Holds the memory address of the next instruction to execute.</li>
<li><strong>Instruction Register (IR):</strong> Stores the current instruction being decoded/executed.</li>
<li><strong>Stack Pointer (SP)</strong>: Tracks the top of the stack in memory.</li>
<li><strong>Status/Flag Register</strong>: Stores metadata about operations (e.g., whether a result was zero or caused an overflow).</li>
</ul>
</li>
</ul>
<h3 id="why-registers-are-essential">Why Registers Are Essential</h3>
<ul>
<li><strong>Eliminate Bottlenecks:</strong> Without registers, the CPU would need to read/write data directly from RAM for every operation, which is too slow.</li>
<li><strong>Enable Pipelining:</strong> Registers allow the CPU to work on multiple instructions simultaneously by holding intermediate states.</li>
<li><strong>Direct Hardware Access:</strong> Registers interface directly with the CPU’s ALU and control unit, enabling rapid execution of machine-level instructions.</li>
</ul>
<h2 id="cpu-cache-l1-l2-l3-cpu-caches">CPU Cache: L1, L2, L3 CPU caches</h2>
<p>CPU Caches are small, ultra-fast memory layers between the CPU and main memory (RAM). They store frequently accessed data and instructions to reduce latency and improve performance. Modern CPUs use three levels of cache:</p>
<p>There are two types of cached instructions:</p>
<ul>
<li><strong>Instruction Cache:</strong>
<ul>
<li><strong>What it stores:</strong>
<ul>
<li>Instructions are the actual binary code (machine code) of the program being executed by the CPU.</li>
<li>Examples: <code>ADD</code>, <code>MOV</code>, <code>JUMP</code>, <code>LOAD</code>, or any operation the CPU performs.</li>
</ul>
</li>
<li><strong>Purpose:</strong>
<ul>
<li>Allows the CPU to quickly fetch the next operation to execute.</li>
<li>For example, when running a loop, the instruction cache holds the repeated code (<code>for</code>, <code>while</code> loops) so the CPU doesn’t have to fetch it repeatedly from slower memory.</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Data Cache:</strong>
<ul>
<li><strong>What it stores:</strong>
<ul>
<li>Data refers to the values the CPU is actively working with.</li>
<li>Examples: Variables (e.g., int x = 5), memory addresses, temporary results, or input/output values.</li>
</ul>
</li>
<li><strong>Purpose:</strong>
<ul>
<li>Provides fast access to the operands (numbers, addresses) needed by instructions.</li>
<li>For example, when calculating x + y, the data cache holds the values of x and y for the ADD instruction to use.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Why Split Them?</strong>
- <strong>Parallel Access:</strong>
* The CPU can fetch the next instruction (from the instruction cache) while simultaneously reading/writing data (from the data cache). This avoids bottlenecks.
* <strong>Example:</strong> While executing an ADD instruction, the CPU can already fetch the next instruction (MOV or JUMP) from the instruction cache.
- <strong>Specialization:</strong>
- Instruction caches are optimized for sequential access (program code is usually read in order).
- Data caches are optimized for random access (variables can be accessed in any order).</p>
<h3 id="l1-cache-level-1-cache">L1 Cache (Level 1 Cache)</h3>
<ul>
<li><strong>Role:</strong>
<ul>
<li>The fastest and smallest cache, directly integrated into the CPU core.</li>
<li>Split into L1 Instruction Cache (stores executable code) and L1 Data Cache (stores data).</li>
</ul>
</li>
<li><strong>Characteristics:</strong>
<ul>
<li><strong>Size:</strong> Typically 32–64 KB per core (e.g., 64 KB total: 32 KB data + 32 KB instructions).</li>
<li><strong>Speed:</strong> 1–4 clock cycles access time (fastest).</li>
<li><strong>Location:</strong> Embedded within each CPU core.</li>
</ul>
</li>
</ul>
<h3 id="l2-cache-level-2-cache">L2 Cache (Level 2 Cache)</h3>
<ul>
<li><strong>Role:</strong>
<ul>
<li>Acts as a middle layer between L1 and L3.</li>
<li>Stores data/instructions not held in L1 but likely to be reused.</li>
</ul>
</li>
<li><strong>Characteristics:</strong>
<ul>
<li><strong>Size:</strong> 256 KB–2 MB per core (varies by CPU design).</li>
<li><strong>Speed</strong>: 10–20 clock cycles access time.</li>
<li><strong>Location</strong>: May be shared between cores or dedicated per core (e.g., AMD Zen vs. Intel Core).</li>
</ul>
</li>
</ul>
<h3 id="l3-cache-level-3-cache">L3 Cache (Level 3 Cache)</h3>
<ul>
<li><strong>Role:</strong>
<ul>
<li>The largest and slowest CPU cache, shared across all cores.</li>
<li>Reduces traffic to RAM by storing data shared between multiple cores.</li>
</ul>
</li>
<li><strong>Characteristics</strong>:
<ul>
<li><strong>Size</strong>: 4–64 MB</li>
<li><strong>Speed</strong>: 20–50 clock cycles access time.</li>
<li><strong>Location</strong>: On the CPU die but outside individual cores.</li>
</ul>
</li>
</ul>
<h3 id="why-three-levels">Why Three Levels?</h3>
<ul>
<li><strong>Latency vs. Size Trade-off:</strong> L1 prioritizes speed for critical data, L2 balances speed and size, and L3 minimizes RAM access.</li>
<li><strong>Efficiency:</strong> Reduces “cache misses” by filtering requests through layers (90% of data is often found in L1/L2).</li>
<li><strong>Multicore Optimization:</strong> L3 enables shared data (e.g., game textures, OS tasks) to stay accessible to all cores.</li>
</ul>
<p><strong>Practical Example:</strong></p>
<ul>
<li>When running a game:
<ul>
<li>L1: Stores code for rendering a character (e.g., position calculations).</li>
<li>L2: Caches textures used in the current scene.</li>
<li>L3: Holds shared assets like audio files or global physics data.</li>
</ul>
</li>
</ul>
<h3 id="why-not-replace-l2-and-l3-with-l1">Why not replace L2 and L3 with L1?</h3>
<ul>
<li><strong>Physical Limits:</strong>
<ul>
<li>L1 is fast but bulky/power-hungry. Scaling it to L2/L3 sizes would make CPUs impractical (cost, heat, latency).</li>
</ul>
</li>
<li><strong>Hierarchy Efficiency</strong>:
<ul>
<li><strong>L1</strong>: Speed-optimized for critical data.</li>
<li><strong>L2</strong>: Balances size/speed for common data.</li>
<li><strong>L3</strong>: Shared, large storage to minimize RAM trips.</li>
</ul>
</li>
<li><strong>Cache Miss Mitigation</strong>:
<ul>
<li>Without L2/L3, frequent RAM access (~100x slower) would cripple performance.</li>
</ul>
</li>
<li><strong>Power/Heat</strong>:
<ul>
<li>Larger L1 would drain power and overheat CPUs.</li>
</ul>
</li>
<li><strong>Multicore Sharing</strong>:
<ul>
<li>L3 allows cores to access shared data without duplicating it in L1/L2.</li>
</ul>
</li>
</ul>
<h2 id="ram-the-parts-of-the-memory-cell">RAM: The Parts of the Memory Cell</h2>
<p>Imagine a single memory cell in your computer’s RAM (the temporary memory your computer uses to do stuff). Think of it like a tiny light switch and a tiny battery working together to store a 0 or a 1 (the basic “yes/no” language computers use). Here’s how it works:</p>
<ul>
<li><strong>Capacitor:</strong> A tiny “battery” that can hold an electric charge.
<ul>
<li>Charged (has electricity) = 1</li>
<li>Not charged (empty) = 0</li>
</ul>
</li>
<li><strong>Transistor:</strong> A tiny “light switch” that controls access to the capacitor.
<ul>
<li>ON (switch closed) = Lets electricity flow.</li>
<li>OFF (switch open) = Blocks electricity.</li>
</ul>
</li>
<li><strong>Address Line:</strong> The wire that tells the transistor to turn ON/OFF.</li>
<li><strong>Data Line:</strong> The wire that reads or writes the charge (0 or 1) to the capacitor.</li>
</ul>
<h3 id="how-it-works">How It Works</h3>
<ol>
<li>Writing Data (Saving a 0 or 1)
<ul>
<li><strong>Step 1:</strong> The CPU (computer’s brain) says, “Hey, I need to save a 1 at this specific memory cell!”</li>
<li><strong>Step 2:</strong> The Address Line sends electricity (like flipping the switch ON).</li>
<li><strong>Step 3:</strong> The Data Line sends electricity to charge the capacitor (filling the tiny battery).
<strong>Result:</strong> Capacitor is charged = 1 is stored.
If the CPU wants to save a 0, the Data Line drains the capacitor instead.</li>
</ul>
</li>
<li>Reading Data (Checking if it’s 0 or 1)
<ul>
<li><strong>Step 1:</strong> The CPU says, “What’s stored at this memory cell?”</li>
<li><strong>Step 2:</strong> The Address Line sends electricity (switch ON).</li>
<li><strong>Step 3:</strong> If the capacitor is charged (storing 1), electricity flows out through the Data Line.
<ul>
<li><strong>Result:</strong> The CPU detects this flow = 1.</li>
</ul>
</li>
<li><strong>Step 4:</strong> If the capacitor is empty (storing 0), no electricity flows.
<ul>
<li><strong>Result:</strong> The CPU detects no flow = 0.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="refresh-cycle">Refresh Cycle</h3>
<ul>
<li>Each DRAM cell consists of a <strong>capacitor (storing a 1 or 0 as charge)</strong> and an <strong>access transistor</strong>.</li>
<li>When a cell is <strong>“charged” (1)</strong> or <strong>“discharged” (0)</strong>, that state is maintained only temporarily because the charge leaks away.</li>
<li>The <strong>DRAM controller (or memory controller)</strong> periodically reads each memory cell and then rewrites (recharges) it to restore the original value. This <strong>refresh cycle</strong> typically occurs every 64–128 milliseconds for all cells.</li>
<li>Without refreshing, the leakage would eventually cause the stored bits to flip, leading to data corruption. The periodic refresh ensures data integrity over time.</li>
</ul>  </div> <div class="blog-post-nav" data-astro-cid-4dqtj3le> <a href="/" class="back-link" data-astro-cid-4dqtj3le>cd ..</a> </div> </article>  </div> </main> <button id="theme-toggle" aria-label="Toggle dark mode" data-astro-cid-x3pjskd3> <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-x3pjskd3> <path class="sun" d="M12 17a5 5 0 1 0 0-10 5 5 0 0 0 0 10zm0-15v2m0 16v2M5.3 5.3l1.4 1.4m10.6 10.6 1.4 1.4M2 12h2m16 0h2M5.3 18.7l1.4-1.4m10.6-10.6 1.4-1.4" data-astro-cid-x3pjskd3></path> <path class="moon" d="M21 12.8A9 9 0 1 1 11.2 3a7 7 0 0 0 10 10z" data-astro-cid-x3pjskd3></path> </svg> </button>   <div id="search-modal" x-data="{ 
    open: false,
    query: '',
    results: [],
    selectedIndex: -1,
    init() {
      this.$watch('open', value => {
        if (value) {
          setTimeout(() => this.$refs.searchInput.focus(), 50);
          document.body.classList.add('modal-open');
        } else {
          document.body.classList.remove('modal-open');
        }
      });
      
      document.addEventListener('toggle-search', () => {
        this.open = !this.open;
        this.query = '';
        this.results = [];
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === '/' && !this.open && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
          this.open = true;
        }
        if (e.key === 'Escape' && this.open) {
          this.open = false;
        }
      });
    },
    search() {
      if (this.query.length < 2) {
        this.results = [];
        return;
      }
      
      const fuseSearch = new window.Fuse(this.searchableContent, {
        keys: ['title', 'description', 'content'],
        includeScore: true,
        threshold: 0.4,
        ignoreLocation: true
      });
      
      this.results = fuseSearch.search(this.query).slice(0, 10);
      this.selectedIndex = this.results.length > 0 ? 0 : -1;
    },
    handleKeyDown(event) {
      if (event.key === 'ArrowDown') {
        event.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.results.length - 1);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
      } else if (event.key === 'Enter' && this.selectedIndex >= 0) {
        event.preventDefault();
        window.location.href = this.results[this.selectedIndex].item.url;
      }
    }
  }" x-init="searchableContent = JSON.parse(decodeURIComponent('<%- encodeURIComponent(JSON.stringify(searchableContent)) %>'))" x-show="open" x-transition:enter="transition ease-out duration-200" x-transition:enter-start="opacity-0 transform scale-95" x-transition:enter-end="opacity-100 transform scale-100" x-transition:leave="transition ease-in duration-150" x-transition:leave-start="opacity-100 transform scale-100" x-transition:leave-end="opacity-0 transform scale-95" class="search-modal" @keydown.escape="open = false" data-astro-cid-qk3db3zz> <div class="search-backdrop" @click="open = false" data-astro-cid-qk3db3zz></div> <div class="search-container" data-astro-cid-qk3db3zz> <div class="search-header" data-astro-cid-qk3db3zz> <div class="terminal-dots" data-astro-cid-qk3db3zz> <div class="dot red" data-astro-cid-qk3db3zz></div> <div class="dot yellow" data-astro-cid-qk3db3zz></div> <div class="dot green" data-astro-cid-qk3db3zz></div> </div> <span class="search-title" data-astro-cid-qk3db3zz>$ grep -r</span> <button class="close-button" @click="open = false" data-astro-cid-qk3db3zz>×</button> </div> <div class="search-content" data-astro-cid-qk3db3zz> <div class="search-input-container" data-astro-cid-qk3db3zz> <input x-ref="searchInput" type="text" placeholder="Search the blog..." x-model="query" @input="search()" @keydown="handleKeyDown($event)" class="search-input" data-astro-cid-qk3db3zz> </div> <div class="search-results" x-show="query.length > 1" data-astro-cid-qk3db3zz> <template x-if="results.length === 0 && query.length > 1" data-astro-cid-qk3db3zz> <div class="no-results" data-astro-cid-qk3db3zz>No results found for "<span x-text="query" data-astro-cid-qk3db3zz></span>"</div> </template> <template x-if="results.length > 0" data-astro-cid-qk3db3zz> <ul class="results-list" data-astro-cid-qk3db3zz> <template x-for="(result, index) in results" :key="result.item.id" data-astro-cid-qk3db3zz> <li class="result-item" :class="{ 'selected': index === selectedIndex }" @click="window.location.href = result.item.url" @mouseover="selectedIndex = index" data-astro-cid-qk3db3zz> <div class="result-title" x-text="result.item.title" data-astro-cid-qk3db3zz></div> <div class="result-date" x-text="new Date(result.item.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })" data-astro-cid-qk3db3zz></div> <div class="result-description" x-text="result.item.description || result.item.content.slice(0, 100) + '...'" data-astro-cid-qk3db3zz></div> </li> </template> </ul> </template> </div> </div> <div class="search-footer" x-show="query.length > 1" data-astro-cid-qk3db3zz> <div class="keyboard-shortcuts" data-astro-cid-qk3db3zz> <span data-astro-cid-qk3db3zz>↑↓ to navigate</span> <span data-astro-cid-qk3db3zz>↵ to select</span> <span data-astro-cid-qk3db3zz>ESC to close</span> </div> </div> </div> </div>  <!-- Fuse.js for search --> <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script> </body> </html>  