<!DOCTYPE html><html lang="en" data-astro-cid-ouamjn2i> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="A terminal-styled developer blog"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><title>Digging into sync.Once: How Go Ensures One-Time Execution</title><link rel="stylesheet" href="/_astro/_slug_.GJexHCZG.css">
<link rel="stylesheet" href="/_astro/_slug_.TTX37v3e.css"><script type="module">const c=document.getElementById("search-button");c?.addEventListener("click",()=>{document.dispatchEvent(new CustomEvent("toggle-search"))});const n=document.getElementById("theme-toggle"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");(e==="dark"||!e&&o)&&document.documentElement.classList.add("dark-theme");n?.addEventListener("click",()=>{const t=document.documentElement.classList.toggle("dark-theme");localStorage.setItem("theme",t?"dark":"light")});
</script>
<script type="module" src="/_astro/page.DZtx3eTe.js"></script></head> <body data-astro-cid-ouamjn2i> <header class="header" data-astro-cid-3ef6ksr2> <div class="terminal-header" data-astro-cid-3ef6ksr2> <div class="terminal-dots" data-astro-cid-3ef6ksr2> <div class="dot red" data-astro-cid-3ef6ksr2></div> <div class="dot yellow" data-astro-cid-3ef6ksr2></div> <div class="dot green" data-astro-cid-3ef6ksr2></div> </div> <nav class="terminal-nav" data-astro-cid-3ef6ksr2> <a href="/" class="command " data-astro-cid-3ef6ksr2>cd ~</a> <a href="/blog" class="command active" data-astro-cid-3ef6ksr2>cd ~/blog</a> <a href="/random" class="command " data-astro-cid-3ef6ksr2>rand</a> <a href="/whoami" class="command " data-astro-cid-3ef6ksr2>whoami</a> <a href="/ping" class="command " data-astro-cid-3ef6ksr2>ping</a> <a href="/assets/resume/PrabhavDogra.pdf" target="_blank" rel="noopener noreferrer" class="command" data-astro-cid-3ef6ksr2>cd ~/resume</a> </nav> <span class="prompt" data-astro-cid-3ef6ksr2>$</span> <button id="search-button" class="search-button" data-astro-cid-3ef6ksr2>
search <span class="search-term" data-astro-cid-3ef6ksr2>--query='search term'</span> </button> </div> </header>   <main class="container" data-astro-cid-ouamjn2i> <div class="content" data-astro-cid-ouamjn2i> <div class="blog-title" data-astro-cid-ouamjn2i>~/blog</div>   <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"> <div class="blog-path" data-astro-cid-4dqtj3le>~/blog/digging-into-sync.once:-how-go-ensures-one-time-execution</div> <article class="blog-post" data-astro-cid-4dqtj3le> <h1 class="blog-post-title" data-astro-cid-4dqtj3le>Digging into sync.Once: How Go Ensures One-Time Execution</h1> <div class="blog-post-date" data-astro-cid-4dqtj3le>üìÖ April 19, 2025</div> <div class="blog-post-content markdown-content" data-astro-cid-4dqtj3le>  <h3 id="how-it-started">How it started?</h3>
<p>While writing some concurrent code for <a href="https://blinkit.com/">Blinkit</a>, I found myself reaching for <code>sync.Once</code>‚Äîa common utility in Go to ensure an action is performed just once, no matter how many goroutines attempt it. Out of curiosity, I decided to dig into how <code>sync.Once</code> works internally and how its implementation has evolved over time. While investigating the internals I came across something interesting and ended up contributing myself ‚Äî a small step, but super rewarding!</p>
<p>In this blog, I‚Äôll walk through the internals of <code>sync.Once</code>, how it leverages atomics for performance, and trace its evolution through Go versions. This blog is meant to motivate you to explore and solve your own doubts by diving into the source code of Go itself. You‚Äôll be amazed at how much you can learn just by following the code and seeing how things work behind the scenes!</p>
<h3 id="prerequisites-whats-synconce">Prerequisites: What‚Äôs sync.Once?</h3>
<ul>
<li><code>sync.Once</code> ensures a function is only executed once, no matter how many times it‚Äôs called, even across goroutines.</li>
<li>It‚Äôs most commonly used to initialize shared resources like config, DB connections, or singletons.</li>
</ul>
<div class="expressive-code"><link rel="stylesheet" href="/_astro/ec.y0rd3.css"><script type="module" src="/_astro/ec.8zarh.js"></script><figure class="frame"><figcaption class="header"></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">var</span><span style="--0:#E1E4E8;--1:#24292E"> (</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">readConfigOnce  </span><span style="--0:#B392F0;--1:#6F42C1">sync</span><span style="--0:#E1E4E8;--1:#24292E">.</span><span style="--0:#B392F0;--1:#6F42C1">Once</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">config          </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Config</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">)</span></div></div><div class="ec-line"><div class="code">
</div></div><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">GetConfig</span><span style="--0:#E1E4E8;--1:#24292E">() (</span><span style="--0:#FFAB70;--1:#AE4B07">c</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Config</span><span style="--0:#E1E4E8;--1:#24292E">) {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">readConfigOnce.</span><span style="--0:#B392F0;--1:#6F42C1">Do</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E">() {</span></div></div><div class="ec-line"><div class="code"><span class="indent">    </span><span style="--0:#99A0A6;--1:#616972">// Read yaml and make config object</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">})</span></div></div><div class="ec-line"><div class="code"><span class="indent">  </span><span style="--0:#F97583;--1:#BF3441">return</span><span style="--0:#E1E4E8;--1:#24292E"> config</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div><div class="ec-line"><div class="code">
</div></div><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">main</span><span style="--0:#E1E4E8;--1:#24292E">() {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">cfg </span><span style="--0:#F97583;--1:#BF3441">:=</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">LoadConfig</span><span style="--0:#E1E4E8;--1:#24292E">()</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">fmt.</span><span style="--0:#B392F0;--1:#6F42C1">Println</span><span style="--0:#E1E4E8;--1:#24292E">(cfg)</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="var (  readConfigOnce  sync.Once  config          *Config)func GetConfig() (c *Config) {  readConfigOnce.Do(func() {    // Read yaml and make config object  })  return config}func main() {  cfg := LoadConfig()  fmt.Println(cfg)}"><div></div></button></div></figure></div>
<p>Link to <a href="https://pkg.go.dev/sync#Once.Do">sync.Once documentation</a></p>
<h2 id="digging-into-synconce-internals">Digging into sync.Once internals?</h2>
<p>To follow along this read feel free to clone the <a href="https://github.com/golang/go">Golang</a> repository.</p>
<ul>
<li>Open the repository and run the bash script <code>./make.bash</code>, to build and install the latest compiler of Go.</li>
<li>Point your system or editor (like VSCode) to use the newly built Go version:</li>
</ul>
<div class="markdown-alert markdown-alert-note" dir="auto">
<p class="markdown-alert-title" dir="auto"><svg class="octicon" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>NOTE</p>
<p><strong>Bootstrapped Compilers</strong></p>
<p>When I first came across the concept of a bootstrapped compiler, it honestly felt like a total brain teaser. The idea that a compiler could be written in the same language it‚Äôs supposed to compile? Wild.</p>
<p>Here‚Äôs the bombshell: <strong>the Go compiler is written in Go itself</strong>.
Sounds paradoxical, right?</p>
<p>Like a classic chicken-and-egg dilemma -
<strong>‚ÄúHow can a compiler compile itself if it doesn‚Äôt exist yet?‚Äù</strong>
In programming, bootstrapping refers to:
The process of building a system using a simpler or initial version of itself.</p>
<ul>
<li><code>make.bash</code> is a shell script located at <code>src/make.bash</code> inside the Go source tree.</li>
<li>It‚Äôs used to bootstrap the Go toolchain ‚Äî it builds the Go compiler (<code>cmd/compile</code>), linker (<code>cmd/link</code>), and other core tools from scratch using the Go bootstrap toolchain.</li>
<li>It uses the already installed Go compiler</li>
<li>Use the clones Golang source code to build the new version of Go.</li>
</ul>
</div>
<h3 id="internals-go-118">Internals (Go 1.18)</h3>
<p>Let‚Äôs start from the basics, struct of <code>sync.Once</code> looks like</p>
<div class="expressive-code"><figure class="frame has-title"><figcaption class="header"><span class="title">src/sync/once.go | GOVERSION=1.18</span></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">type</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">Once</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">struct</span><span style="--0:#E1E4E8;--1:#24292E"> {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">done </span><span style="--0:#F97583;--1:#BF3441">uint32</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">m    </span><span style="--0:#B392F0;--1:#6F42C1">Mutex</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="type Once struct {  done uint32  m    Mutex}"><div></div></button></div></figure></div>
<p>Pretty simple, right?</p>
<ul>
<li>One <code>uint32</code> flag <code>done</code>
<ul>
<li><code>done == 1</code> means that the function has ran once</li>
<li><code>done == 0</code> means that the function hasn‚Äôt ran yet</li>
</ul>
</li>
<li>One mutex <code>m</code>
<ul>
<li>A mutex to avoid race condition while updating <code>done</code></li>
</ul>
</li>
</ul>
<p>Ok, somehow these two are used together to:</p>
<ul>
<li>Ensure that a particular action executes only once, regardless of how many times it is called concurrently.</li>
<li>Achieve this guarantee efficiently, minimizing lock contention for better performance.</li>
</ul>
<p>Ok so far so good right?</p>
<p>Let‚Äôs move to the implementation of <code>once.Do(f)</code>: It ensures that the function <code>f()</code> is only executed once, no matter how many times it‚Äôs called‚Äîeven if from multiple goroutines.</p>
<div class="expressive-code"><figure class="frame has-title"><figcaption class="header"><span class="title">src/sync/once.go | GOVERSION=1.18</span></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> (</span><span style="--0:#FFAB70;--1:#AE4B07">o </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Once</span><span style="--0:#E1E4E8;--1:#24292E">) </span><span style="--0:#B392F0;--1:#6F42C1">Do</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#FFAB70;--1:#AE4B07">f</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E">()) {</span></div></div><div class="ec-line"><div class="code"><span class="indent">  </span><span style="--0:#F97583;--1:#BF3441">if</span><span style="--0:#E1E4E8;--1:#24292E"> atomic.</span><span style="--0:#B392F0;--1:#6F42C1">LoadUint32</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">&#x26;</span><span style="--0:#E1E4E8;--1:#24292E">o.done) </span><span style="--0:#F97583;--1:#BF3441">==</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#79B8FF;--1:#005CC5">0</span><span style="--0:#E1E4E8;--1:#24292E"> {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">    </span></span><span style="--0:#E1E4E8;--1:#24292E">o.</span><span style="--0:#B392F0;--1:#6F42C1">doSlow</span><span style="--0:#E1E4E8;--1:#24292E">(f)</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="func (o *Once) Do(f func()) {  if atomic.LoadUint32(&#x26;o.done) == 0 {    o.doSlow(f)  }}"><div></div></button></div></figure></div>
<p><strong>Goal:</strong> Avoid acquiring a mutex unless absolutely necessary (i.e., the function <code>f()</code> hasn‚Äôt run yet).</p>
<ul>
<li><code>if atomic.LoadUint32(&#x26;o.done) == 0</code>
<ul>
<li>We check if <code>done == 0</code>, <code>done == 0</code> means that the function hasn‚Äôt ran yet</li>
<li>It checks <code>done == 0</code> atomically in one operation. More about <a href="https://prabhavdogra.github.io/prabhav.tech/blog/atomic_operations"><code>atomic package</code></a></li>
</ul>
</li>
</ul>
<div class="expressive-code"><figure class="frame"><figcaption class="header"></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> (</span><span style="--0:#FFAB70;--1:#AE4B07">o </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Once</span><span style="--0:#E1E4E8;--1:#24292E">) </span><span style="--0:#B392F0;--1:#6F42C1">doSlow</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#FFAB70;--1:#AE4B07">f</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E">()) {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">o.m.</span><span style="--0:#B392F0;--1:#6F42C1">Lock</span><span style="--0:#E1E4E8;--1:#24292E">()</span></div></div><div class="ec-line"><div class="code"><span class="indent">  </span><span style="--0:#F97583;--1:#BF3441">defer</span><span style="--0:#E1E4E8;--1:#24292E"> o.m.</span><span style="--0:#B392F0;--1:#6F42C1">Unlock</span><span style="--0:#E1E4E8;--1:#24292E">()</span></div></div><div class="ec-line"><div class="code"><span class="indent">  </span><span style="--0:#F97583;--1:#BF3441">if</span><span style="--0:#E1E4E8;--1:#24292E"> o.done </span><span style="--0:#F97583;--1:#BF3441">==</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#79B8FF;--1:#005CC5">0</span><span style="--0:#E1E4E8;--1:#24292E"> {</span></div></div><div class="ec-line"><div class="code"><span class="indent">    </span><span style="--0:#F97583;--1:#BF3441">defer</span><span style="--0:#E1E4E8;--1:#24292E"> atomic.</span><span style="--0:#B392F0;--1:#6F42C1">StoreUint32</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">&#x26;</span><span style="--0:#E1E4E8;--1:#24292E">o.done, </span><span style="--0:#79B8FF;--1:#005CC5">1</span><span style="--0:#E1E4E8;--1:#24292E">)</span></div></div><div class="ec-line"><div class="code"><span class="indent">    </span><span style="--0:#B392F0;--1:#6F42C1">f</span><span style="--0:#E1E4E8;--1:#24292E">()</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="func (o *Once) doSlow(f func()) {  o.m.Lock()  defer o.m.Unlock()  if o.done == 0 {    defer atomic.StoreUint32(&#x26;o.done, 1)    f()  }}"><div></div></button></div></figure></div>
<ul>
<li><code>if o.done == 0</code>
<ul>
<li>A second check inside the locked section.</li>
<li>Why? Because multiple goroutines might pass the atomic check in Do(), but only one should actually run the function. So we check again inside the lock to be 100% sure.</li>
<li>This is a double-checked locking pattern.</li>
</ul>
</li>
</ul>
<ul>
<li><code>defer atomic.StoreUint32(&#x26;o.done, 1)</code>
<ul>
<li>Marks the function as executed after <code>f()</code> is done.</li>
<li>It‚Äôs deferred so even if <code>f()</code> panics, we still consider it ‚Äúdone‚Äù and don‚Äôt call it again (intentional in Go‚Äôs design).</li>
</ul>
</li>
</ul>
<h3 id="internals-go-124">Internals (Go 1.24)</h3>
<p>In newer versions of Go they revised the implementation of how <code>sync.Once</code>.</p>
<div class="expressive-code"><figure class="frame has-title"><figcaption class="header"><span class="title">src/sync/once.go | GOVERSION=1.24</span></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">type</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">Once</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">struct</span><span style="--0:#E1E4E8;--1:#24292E"> {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">_ </span><span style="--0:#B392F0;--1:#6F42C1">noCopy</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">done </span><span style="--0:#B392F0;--1:#6F42C1">atomic</span><span style="--0:#E1E4E8;--1:#24292E">.</span><span style="--0:#B392F0;--1:#6F42C1">Uint32</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">m    </span><span style="--0:#B392F0;--1:#6F42C1">Mutex</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="type Once struct {  _ noCopy  done atomic.Uint32  m    Mutex}"><div></div></button></div></figure></div>
<p>Ok!
What‚Äôs changed now?</p>
<ul>
<li><code>noCopy</code> is embedded in <code>Once</code> struct</li>
<li>done is <code>atomic.Uint32</code> not <code>uint32</code></li>
</ul>
<h4 id="nocopy-whats-that">‚ÄùnoCopy‚Äù What‚Äôs that?</h4>
<ul>
<li>It‚Äôa a zero-size struct that is adds no memory overhead.</li>
<li>Go has a statical analysis tool <code>go vet</code> that checks your Go source code for common mistakes and suspicious constructs that the compiler won‚Äôt catch.</li>
<li>Some types must never be copied once they‚Äôve been initialized‚Äîmost notably synchronization primitives like <code>sync.Mutex</code>, <code>sync.Once</code>, etc. Accidental copies can lead to deadlocks or data races.</li>
<li>Having <code>noCopy</code> embedded in your struct will produce a warning if your type is ever copied by <code>go vet</code>.</li>
</ul>
<h4 id="regular-uint32-vs-atomicuint32">Regular uint32 vs. atomic.Uint32</h4>
<p>When you don‚Äôt know something in Go let‚Äôs follow the approach like we have done, and let‚Äôs look at the source code:</p>
<div class="expressive-code"><figure class="frame has-title"><figcaption class="header"><span class="title">src/atomic/type.go | GOVERSION=1.24</span></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">type</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">Uint32</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">struct</span><span style="--0:#E1E4E8;--1:#24292E"> {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">_ </span><span style="--0:#B392F0;--1:#6F42C1">noCopy</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">v </span><span style="--0:#F97583;--1:#BF3441">uint32</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="type Uint32 struct {  _ noCopy  v uint32}"><div></div></button></div></figure></div>
<ul>
<li>Ok, wow! As you can see <code>atomic.Uint32</code> is just a wrapper type around a uint32 with <code>noCopy</code> but why???</li>
</ul>
<p>Let‚Äôs look further functions binded to this struct:</p>
<div class="expressive-code"><figure class="frame"><figcaption class="header"></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#99A0A6;--1:#616972">// Load atomically loads and returns the value stored in x.</span></div></div><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> (</span><span style="--0:#FFAB70;--1:#AE4B07">x </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Uint32</span><span style="--0:#E1E4E8;--1:#24292E">) </span><span style="--0:#B392F0;--1:#6F42C1">Load</span><span style="--0:#E1E4E8;--1:#24292E">() </span><span style="--0:#F97583;--1:#BF3441">uint32</span><span style="--0:#E1E4E8;--1:#24292E"> { </span><span style="--0:#F97583;--1:#BF3441">return</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">LoadUint32</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">&#x26;</span><span style="--0:#E1E4E8;--1:#24292E">x.v) }</span></div></div><div class="ec-line"><div class="code">
</div></div><div class="ec-line"><div class="code"><span style="--0:#99A0A6;--1:#616972">// Store atomically stores val into x.</span></div></div><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> (</span><span style="--0:#FFAB70;--1:#AE4B07">x </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Uint32</span><span style="--0:#E1E4E8;--1:#24292E">) </span><span style="--0:#B392F0;--1:#6F42C1">Store</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#FFAB70;--1:#AE4B07">val</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">uint32</span><span style="--0:#E1E4E8;--1:#24292E">) { </span><span style="--0:#B392F0;--1:#6F42C1">StoreUint32</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">&#x26;</span><span style="--0:#E1E4E8;--1:#24292E">x.v, val) }</span></div></div><div class="ec-line"><div class="code">
</div></div><div class="ec-line"><div class="code"><span style="--0:#99A0A6;--1:#616972">// Swap atomically stores new into x and returns the previous value.</span></div></div><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> (</span><span style="--0:#FFAB70;--1:#AE4B07">x </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Uint32</span><span style="--0:#E1E4E8;--1:#24292E">) </span><span style="--0:#B392F0;--1:#6F42C1">Swap</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#FFAB70;--1:#AE4B07">new</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">uint32</span><span style="--0:#E1E4E8;--1:#24292E">) (</span><span style="--0:#FFAB70;--1:#AE4B07">old</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">uint32</span><span style="--0:#E1E4E8;--1:#24292E">) { </span><span style="--0:#F97583;--1:#BF3441">return</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">SwapUint32</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">&#x26;</span><span style="--0:#E1E4E8;--1:#24292E">x.v, new) }</span></div></div><div class="ec-line"><div class="code">
</div></div><div class="ec-line"><div class="code"><span style="--0:#99A0A6;--1:#616972">// CompareAndSwap executes the compare-and-swap operation for x.</span></div></div><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">func</span><span style="--0:#E1E4E8;--1:#24292E"> (</span><span style="--0:#FFAB70;--1:#AE4B07">x </span><span style="--0:#F97583;--1:#BF3441">*</span><span style="--0:#B392F0;--1:#6F42C1">Uint32</span><span style="--0:#E1E4E8;--1:#24292E">) </span><span style="--0:#B392F0;--1:#6F42C1">CompareAndSwap</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#FFAB70;--1:#AE4B07">old</span><span style="--0:#E1E4E8;--1:#24292E">, </span><span style="--0:#FFAB70;--1:#AE4B07">new</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">uint32</span><span style="--0:#E1E4E8;--1:#24292E">) (</span><span style="--0:#FFAB70;--1:#AE4B07">swapped</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">bool</span><span style="--0:#E1E4E8;--1:#24292E">) { </span><span style="--0:#F97583;--1:#BF3441">return</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">CompareAndSwapUint32</span><span style="--0:#E1E4E8;--1:#24292E">(</span><span style="--0:#F97583;--1:#BF3441">&#x26;</span><span style="--0:#E1E4E8;--1:#24292E">x.v, old, new) }</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="// Load atomically loads and returns the value stored in x.func (x *Uint32) Load() uint32 { return LoadUint32(&#x26;x.v) }// Store atomically stores val into x.func (x *Uint32) Store(val uint32) { StoreUint32(&#x26;x.v, val) }// Swap atomically stores new into x and returns the previous value.func (x *Uint32) Swap(new uint32) (old uint32) { return SwapUint32(&#x26;x.v, new) }// CompareAndSwap executes the compare-and-swap operation for x.func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool) { return CompareAndSwapUint32(&#x26;x.v, old, new) }"><div></div></button></div></figure></div>
<p>Ok, seems like it‚Äôs just a wrapper type provides methods for atomic operations.</p>
<p>And that is exactly what <code>atomic.Uint32</code> is:</p>
<blockquote>
<p>A Go¬†1.19+ wrapper type around a uint32 that provides methods for atomic operations</p>
</blockquote>
<h3 id="bonus-go-125-hopefully">Bonus: Go. 1.25 (Hopefully)</h3>
<p>While exploring the internals of <code>sync.Once</code>, I noticed that the done field ‚Äî which indicates whether the function has already been executed ‚Äî was originally an <code>atomic.Uint32</code>.</p>
<p>However, since it‚Äôs only ever used as a boolean flag (0 or 1), I realized it could be more semantically clear to use <code>atomic.Bool</code> instead. Even though atomic.Bool is just a thin wrapper around a uint32 under the hood, switching to it makes the code more self-explanatory and aligns better with the intent of the field.
So I decided to raise a PR and it got merged <code>:)</code></p>
<p>Now the struct looks like this:</p>
<div class="expressive-code"><figure class="frame has-title"><figcaption class="header"><span class="title">src/sync/once.go | GOVERSION=1.25</span></figcaption><pre data-language="go"><code><div class="ec-line"><div class="code"><span style="--0:#F97583;--1:#BF3441">type</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#B392F0;--1:#6F42C1">Once</span><span style="--0:#E1E4E8;--1:#24292E"> </span><span style="--0:#F97583;--1:#BF3441">struct</span><span style="--0:#E1E4E8;--1:#24292E"> {</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">_ </span><span style="--0:#B392F0;--1:#6F42C1">noCopy</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">done </span><span style="--0:#B392F0;--1:#6F42C1">atomic</span><span style="--0:#E1E4E8;--1:#24292E">.</span><span style="--0:#B392F0;--1:#6F42C1">Bool</span></div></div><div class="ec-line"><div class="code"><span class="indent"><span style="--0:#E1E4E8;--1:#24292E">  </span></span><span style="--0:#E1E4E8;--1:#24292E">m    </span><span style="--0:#B392F0;--1:#6F42C1">Mutex</span></div></div><div class="ec-line"><div class="code"><span style="--0:#E1E4E8;--1:#24292E">}</span></div></div></code></pre><div class="copy"><button title="Copy to clipboard" data-copied="Copied!" data-code="type Once struct {  _ noCopy  done atomic.Bool  m    Mutex}"><div></div></button></div></figure></div>
<h2 id="conclusion">Conclusion</h2>
<p>Exploring <code>sync.Once</code> from <strong>Go¬†1.18</strong> to <strong>Go¬†1.25</strong> shows how a small, fundamental primitive can evolve for clarity, safety, and maintainability:</p>
<ul>
<li><strong>Go¬†1.18</strong>
<ul>
<li>Used a plain uint32 flag plus a Mutex and double‚Äëchecked locking</li>
<li>Minimized lock contention by atomically checking the flag on the fast path</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>Go¬†1.24</strong></p>
<ul>
<li>Embeds <code>noCopy</code> to catch accidental copies via go vet</li>
<li>Switches to <code>atomic.Uint32</code>, providing a clean, method‚Äëbased API</li>
</ul>
</li>
<li>
<p><strong>Go¬†1.25</strong></p>
<ul>
<li>Switches <code>atomic.Uint32</code> to <code>atomic.Bool</code></li>
</ul>
</li>
</ul>
<p>Along the way we‚Äôve seen:</p>
<ul>
<li><strong>Bootstrapping</strong> ‚Äì how Go builds itself from source via make.bash</li>
<li><strong>Atomic vs. mutex</strong> ‚Äì why lock‚Äëfree fast paths matter in high‚Äëconcurrency code</li>
<li><strong>Static analysis</strong> ‚Äì how noCopy and go vet help prevent subtle bugs</li>
</ul>
<p>The beauty of Go‚Äôs standard library is that it balances performance, safety, and readability. Whenever you have a question about how Go works under the hood, the answer is just a GitHub clone and a make.bash away. Dive into the source, follow the code, and you‚Äôll not only solve your doubts‚Äîyou‚Äôll discover deeper principles that make Go such a pleasure to work with.</p>
<p>And it‚Äôs downright fun to see how these technologies evolve over time.</p>  </div> <div class="blog-post-nav" data-astro-cid-4dqtj3le> <a href="/" class="back-link" data-astro-cid-4dqtj3le>cd ..</a> </div> </article>  </div> </main> <button id="theme-toggle" aria-label="Toggle dark mode" data-astro-cid-x3pjskd3> <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-x3pjskd3> <path class="sun" d="M12 17a5 5 0 1 0 0-10 5 5 0 0 0 0 10zm0-15v2m0 16v2M5.3 5.3l1.4 1.4m10.6 10.6 1.4 1.4M2 12h2m16 0h2M5.3 18.7l1.4-1.4m10.6-10.6 1.4-1.4" data-astro-cid-x3pjskd3></path> <path class="moon" d="M21 12.8A9 9 0 1 1 11.2 3a7 7 0 0 0 10 10z" data-astro-cid-x3pjskd3></path> </svg> </button>   <div id="search-modal" x-data="{ 
    open: false,
    query: '',
    results: [],
    selectedIndex: -1,
    init() {
      this.$watch('open', value => {
        if (value) {
          setTimeout(() => this.$refs.searchInput.focus(), 50);
          document.body.classList.add('modal-open');
        } else {
          document.body.classList.remove('modal-open');
        }
      });
      
      document.addEventListener('toggle-search', () => {
        this.open = !this.open;
        this.query = '';
        this.results = [];
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === '/' && !this.open && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
          this.open = true;
        }
        if (e.key === 'Escape' && this.open) {
          this.open = false;
        }
      });
    },
    search() {
      if (this.query.length < 2) {
        this.results = [];
        return;
      }
      
      const fuseSearch = new window.Fuse(this.searchableContent, {
        keys: ['title', 'description', 'content'],
        includeScore: true,
        threshold: 0.4,
        ignoreLocation: true
      });
      
      this.results = fuseSearch.search(this.query).slice(0, 10);
      this.selectedIndex = this.results.length > 0 ? 0 : -1;
    },
    handleKeyDown(event) {
      if (event.key === 'ArrowDown') {
        event.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.results.length - 1);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
      } else if (event.key === 'Enter' && this.selectedIndex >= 0) {
        event.preventDefault();
        window.location.href = this.results[this.selectedIndex].item.url;
      }
    }
  }" x-init="searchableContent = JSON.parse(decodeURIComponent('<%- encodeURIComponent(JSON.stringify(searchableContent)) %>'))" x-show="open" x-transition:enter="transition ease-out duration-200" x-transition:enter-start="opacity-0 transform scale-95" x-transition:enter-end="opacity-100 transform scale-100" x-transition:leave="transition ease-in duration-150" x-transition:leave-start="opacity-100 transform scale-100" x-transition:leave-end="opacity-0 transform scale-95" class="search-modal" @keydown.escape="open = false" data-astro-cid-qk3db3zz> <div class="search-backdrop" @click="open = false" data-astro-cid-qk3db3zz></div> <div class="search-container" data-astro-cid-qk3db3zz> <div class="search-header" data-astro-cid-qk3db3zz> <div class="terminal-dots" data-astro-cid-qk3db3zz> <div class="dot red" data-astro-cid-qk3db3zz></div> <div class="dot yellow" data-astro-cid-qk3db3zz></div> <div class="dot green" data-astro-cid-qk3db3zz></div> </div> <span class="search-title" data-astro-cid-qk3db3zz>$ grep -r</span> <button class="close-button" @click="open = false" data-astro-cid-qk3db3zz>√ó</button> </div> <div class="search-content" data-astro-cid-qk3db3zz> <div class="search-input-container" data-astro-cid-qk3db3zz> <input x-ref="searchInput" type="text" placeholder="Search the blog..." x-model="query" @input="search()" @keydown="handleKeyDown($event)" class="search-input" data-astro-cid-qk3db3zz> </div> <div class="search-results" x-show="query.length > 1" data-astro-cid-qk3db3zz> <template x-if="results.length === 0 && query.length > 1" data-astro-cid-qk3db3zz> <div class="no-results" data-astro-cid-qk3db3zz>No results found for "<span x-text="query" data-astro-cid-qk3db3zz></span>"</div> </template> <template x-if="results.length > 0" data-astro-cid-qk3db3zz> <ul class="results-list" data-astro-cid-qk3db3zz> <template x-for="(result, index) in results" :key="result.item.id" data-astro-cid-qk3db3zz> <li class="result-item" :class="{ 'selected': index === selectedIndex }" @click="window.location.href = result.item.url" @mouseover="selectedIndex = index" data-astro-cid-qk3db3zz> <div class="result-title" x-text="result.item.title" data-astro-cid-qk3db3zz></div> <div class="result-date" x-text="new Date(result.item.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })" data-astro-cid-qk3db3zz></div> <div class="result-description" x-text="result.item.description || result.item.content.slice(0, 100) + '...'" data-astro-cid-qk3db3zz></div> </li> </template> </ul> </template> </div> </div> <div class="search-footer" x-show="query.length > 1" data-astro-cid-qk3db3zz> <div class="keyboard-shortcuts" data-astro-cid-qk3db3zz> <span data-astro-cid-qk3db3zz>‚Üë‚Üì to navigate</span> <span data-astro-cid-qk3db3zz>‚Üµ to select</span> <span data-astro-cid-qk3db3zz>ESC to close</span> </div> </div> </div> </div>  <!-- Fuse.js for search --> <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script> </body> </html>  